<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>Particles</title>
	<link rel="stylesheet" type="text/css" href="./css/styles.css" />
	<link rel="shortcut icon" href="favicon.ico" />
	<script language="JavaScript" type="text/javascript" src="./js/jscript.js"></script>
	<link type="text/css" rel="StyleSheet" href="./css/winclassic.css" />
	<script type="text/javascript" src="./js/range.js"></script>
	<script type="text/javascript" src="./js/timer.js"></script>
	<script type="text/javascript" src="./js/slider.js"></script>
  <script type="text/javascript" src="./js/canvasUtil.js"></script>
</head>

 <body onload="init();">

<div class="container">

<div class="topsmall">

<div class="topleftsmall">
   <a href="./index.html">
	<script type="text/javascript">
      		showImage("300x50");
   	</script>
   </a>
</div>

<h1><a href="./index.html">Michael Bradford Williams</a></h1>
</div>

<div class="middle">

<h2>Particles in a gravitational field</h2>

<p>Here's a simple simulation of particles (the colorful circles) in a (classical) gravitational field generated by randomly placed attractors (the black circles).  The controls should be self-explanatory.</p>

<p>You'll need a modern browser to view the app. It has been tested in <a
href="http://www.mozilla.com/firefox/">Firefox</a> (Windows/Linux) and <a
href="http://www.google.com/chrome">Chrome</a> (Windows).</p> </div>

<div class="middle">
	<table border="0" align="center">
		<tr>
			<td align="right"><p>Number of Particles:</p></td>
			<td><div class="slider" id="partSlider" tabIndex="1">
				<input class="slider-input" id="partSliderInput"/></div></td>
			<td><input id="part-view" size="2" /></td>
      <td></td>
			<td><input type="button" name="refresh-part" value="Refresh Particles" onClick="refreshParticles();" /></td>
    </tr>

		<tr>
			<td align="right"><p>Number of Attractors:</p></td>
			<td><div class="slider" id="attSlider" tabIndex="1">
				<input class="slider-input" id="attSliderInput"/></div></td>
			<td><input id="att-view" size="2" /></td>
      <td></td>
      <td><input type="button" name="refresh-att" value="Refresh Attractors" onClick="refreshAttractors();" /></td>
    </tr>

		<tr>
      <td align="right"><p>Gravity Strength:</p></td>
			<td><div class="slider" id="gSlider" tabIndex="1">
				<input class="slider-input" id="gSliderInput"/></div></td>
			<td><input id="g-view" size="2" /></td>
      <td></td>
      <td><input type="button" name="pause" value="Pause Animation" onClick="pauseDrawing();">
		</tr>

		<tr>
			<td align="right"><p>Confine Particles to Canvas:</p></td>
			<td><select id="confine">
					<option value="0" selected>Yes</option>
					<option value="1">No</option>
				</select></td>
    </tr>

    <tr>
      <td align="right"><p>Particles contribute to gravity:</p></td>
			<td><select id="massive">
					<option value="0" selected>Yes</option>
					<option value="1">No</option>
				</select></td>
		</tr>
	</table>
<script type="text/javascript">

var canvas;
var ctx;
var WIDTH = 750;
var HEIGHT = 750;
var canvasUtil;
var ensemble;
var paused = false;

var COLOR = "rgb(255,255,255)";
const ATTRACTOR_COLOR = "black";

var SPEED_MAX = 20;
var ACC_MAX = 1;
var PARTICLE_MASS_MAX = 5;

var NUM_PARTICLES_MIN = 1;
var NUM_PARTICLES = 1;
var NUM_PARTICLES_MAX = 10;

var NUM_ATTRACTORS_MIN = 1;
var NUM_ATTRACTORS = 1;
var NUM_ATTRACTORS_MAX = 5;

var TAIL = 10;

var ATT_MASS_MIN = 100;
var ATT_MASS_MOD = 300;

var G_POW_MIN = 1;
var G_POW = 5;
var G_POW_MAX = 10;

var partSl = new Slider(document.getElementById("partSlider"), document.getElementById("partSliderInput"));
var attSl  = new Slider(document.getElementById("attSlider"),  document.getElementById("attSliderInput"));
var gSl    = new Slider(document.getElementById("gSlider"),    document.getElementById("gSliderInput"));

partSl.setMinimum(NUM_PARTICLES_MIN);
partSl.setValue(NUM_PARTICLES);
partSl.setMaximum(NUM_PARTICLES_MAX);
document.getElementById("part-view").value = NUM_PARTICLES;

attSl.setMinimum(NUM_ATTRACTORS_MIN);
attSl.setValue(NUM_ATTRACTORS);
attSl.setMaximum(NUM_ATTRACTORS_MAX);
document.getElementById("att-view").value = NUM_ATTRACTORS;

gSl.setMinimum(G_POW_MIN);
gSl.setValue(G_POW);
gSl.setMaximum(G_POW_MAX);
document.getElementById("g-view").value = G_POW;


function pauseDrawing() {
	paused = !paused;
}

function refreshParticles() {
  ensemble.particles = Particle.makeRandom(NUM_PARTICLES_MAX);
}

function refreshAttractors() {
  ensemble.attractors = Attractor.makeRandom(NUM_ATTRACTORS_MAX);
}

class Attractor {
  constructor(x, y, mass, color) {
    this.x = x;
    this.y = y;
    this.mass = mass;
    this.color = color;
  }

  toString() {
    return `attractor: pos = (${this.x.toFixed(3)}, ${this.y.toFixed(3)}); mass = ${this.mass.toFixed(3)}`;
  }

  draw() {
    canvasUtil.drawDisk(this.x, this.y, Math.sqrt(this.mass), this.color);
  }

  static makeRandom(n) {
    let attractors = [];
    for (let i=0; i<n; i++) {
  		// let x = WIDTH / 2.0;  //(Math.random() * WIDTH + 1) % WIDTH; //random integer between 0 and WIDTH-1
  		// let y = HEIGHT / 2.0; //(Math.random() * HEIGHT + 1) % HEIGHT; //random integer between 0 and HEIGHT-1
  		// let mass  = 1000; //(Math.random() * ATT_MASS_MOD + 1) % ATT_MASS_MOD + ATT_MASS_MIN; //random integer

      let mid_x = WIDTH / 2.0;
      let mid_y = HEIGHT / 2.0;
      let x = Math.random() * (WIDTH * 0.5) + WIDTH * 0.25; //(Math.random() * WIDTH + 1) % WIDTH; //random integer between 0 and WIDTH-1
      let y = Math.random() * (HEIGHT * 0.5) + HEIGHT * 0.25;  //Math.random() * HEIGHT + 1) % HEIGHT; //random integer between 0 and HEIGHT-1
      let mass = Math.random() * (ATT_MASS_MOD + 1) + ATT_MASS_MIN; //(Math.random() * ATT_MASS_MOD + 1) % ATT_MASS_MOD + ATT_MASS_MIN; //random integer

      attractors.push(new Attractor(x, y, mass, ATTRACTOR_COLOR));
  	}
    return attractors;
  }
}

class Particle {
  constructor(x, y, v_x, v_y, a_x, a_y, mass, color, tail_len) {
    // TODO: refactor to use a Point or Vector object for position, velocity, acceleration

    // each position is an array holding (at most) the previous TAIL_MAX positions
    // the most recent position is first in the array
    this.xs = new Array(TAIL).fill(x);
    this.ys = new Array(TAIL).fill(y);
    this.v_x = v_x;
    this.v_y = v_y;
    this.a_x = a_x;
    this.a_y = a_y;
    this.mass = mass;
    this.color = color;
    this.tail_len = tail_len;
  }

  toString() {
    let p = `pos = (${this.xs[0].toFixed(3)}, ${this.ys[0].toFixed(3)})`;
    let v = `vel = (${this.v_x.toFixed(3)}, ${this.v_y.toFixed(3)})`;
    let a = `acc = (${this.a_x.toFixed(3)}, ${this.a_y.toFixed(3)})`;
    let m = `mass = ${this.mass.toFixed(3)}`;
    return "particle: " + [p, v, a, m].join('; ');
  }

  draw() {
    // to create a tail effect, draw history of positions with older => smaller
    // this doesn't fit too easily into the CanvasUtil framework :/
    ctx.beginPath();
    ctx.fillStyle = this.color;
  	for (let j=0; j<this.tail_len; j++) {
      let radius = 2 * this.mass * (this.tail_len - j) / this.tail_len;
      ctx.arc(this.xs[j], this.ys[j], radius, 0, 2 * Math.PI, true)
    }
    ctx.closePath();
    ctx.fill();
  }

  static makeRandom(n) {
    let particles = [];
    for (let i=0; i<n; i++) {
      // fill position and velocity randomly
      // let pos_x = WIDTH / 2.0; //(Math.random() * WIDTH + 1) % WIDTH; //random integer between 0 and WIDTH-1
      // let pos_y = HEIGHT / 5.0; //(Math.random() * HEIGHT + 1) % HEIGHT; //random integer between 0 and WIDTH-1
      // // random velocity
      // let vel_x = -12.0; //2 * Math.random() - 1.0;
      // let vel_y = 0.0; //2 * Math.random() - 1.0;
      // // no initial acceleration
      // let acc_x = 0.0;
      // let acc_y = 0.0;
      // // random mass
      // let mass = 5.0; //(Math.random() * 4 + 1) % 4 + 1; //random integer between 1 and 4

      let pos_x = Math.random() * (WIDTH + 1);
      let pos_y = Math.random() * (HEIGHT + 1);
      // random velocity vector: random angle and speed
      let theta = Math.random() * 2 * Math.PI;
      let speed = Math.random() * SPEED_MAX / 10;
      let vel_x = speed * Math.cos(theta);
      let vel_y = speed * Math.sin(theta);
      // no initial acceleration
      let acc_x = 0.0;
      let acc_y = 0.0;
      // random mass and color
      let mass = Math.random() * PARTICLE_MASS_MAX + 1;
      let color = `rgb(${Math.random() * 256}, ${Math.random() * 256}, ${Math.random() * 256})`;

      particles.push(new Particle(pos_x, pos_y, vel_x, vel_y, acc_x, acc_y, mass, color, TAIL));
    }
    return particles;
  }
}


class Ensemble {
  constructor(particles, attractors) {
    this.particles = particles; // array of Particle objects
    this.attractors = attractors; // array of Attractor objects
  }

  toString(active) {
    let s = `Ensemble has ${this.particles.length} particles and ${this.attractors.length} attractors`;
    if (active) {
      s = `Ensemble has ${this.particles.slice(0, NUM_PARTICLES).length} particles and ${this.attractors.slice(0, NUM_ATTRACTORS).length} attractors`;
      for (let i in this.particles.slice(0, NUM_PARTICLES)) {
        s += "\n  " + this.particles[i].toString();
      }
      for (let i in this.Attractor.slice(0, NUM_ATTRACTORS)) {
        s += "\n  " + this.attractors[i].toString()
      }
    }
    return s;
  }

  static makeRandom(num_particles, num_attractors) {
    let particles = Particle.makeRandom(num_particles);
    let attractors = Attractor.makeRandom(num_attractors);
    //canvasUtil.println(`created new ensemble with ${particles.length} particles and ${attractors.length} attractors`);
    return new Ensemble(particles, attractors);
  }

  drawAttractors() {
    this.attractors.slice(0, NUM_ATTRACTORS).forEach(a => a.draw());
  }

  drawParticles() {
    this.particles.slice(0, NUM_PARTICLES).forEach(p => p.draw());
  }

  updateState() { //num_particles, num_attractors, massive_particles, confine_particles) {
  	// update each position, velocity, acceleration
  	for (let i=0; i<NUM_PARTICLES; i++) {
  		// TODO: what is going on here?
      //let G = 1 / (10 * Math.pow(10, -1 * G_POW / 5));
      let G = Math.pow(10, G_POW / 5);

  		// reset accelerations
  		this.particles[i].a_x = 0.0;
      this.particles[i].a_y = 0.0;

  		// update acceleration using forces from the attractors
  		for (let j=0; j<NUM_ATTRACTORS; j++) {
        let r_x = this.particles[i].xs[0] - this.attractors[j].x;
        let r_y = this.particles[i].ys[0] - this.attractors[j].y;
        //canvasUtil.println(`diff: (${r_x}, ${r_y})`);
        let r_squared = r_x * r_x + r_y * r_y;
        // law of graviation
  			this.particles[i].a_x += -1.0 * r_x * G * this.attractors[j].mass / Math.pow(r_squared, 1.5);
  			this.particles[i].a_y += -1.0 * r_y * G * this.attractors[j].mass / Math.pow(r_squared, 1.5);
  		}

  		if (document.getElementById("massive").value == 0) {
  			// forces from the other particles
  			for (var j=0; j<NUM_PARTICLES; j++) {
  				if (j != i) {
            let r_x = this.particles[i].xs[0] - this.particles[j].xs[0];
            let r_y = this.particles[i].ys[0] - this.particles[j].ys[0];
  					let r_squared = r_x * r_x + r_y * r_y;
  					this.particles[i].a_x += -1.0 * r_x * G * this.particles[j].mass / Math.pow(r_squared, 1.5);
  					this.particles[i].a_y += -1.0 * r_y * G * this.particles[j].mass / Math.pow(r_squared, 1.5);
  				}
  			}
  		}

      // if norm of acceleraton is too high, rescale the acceleraton vector to have appropriate length
      let acc_norm = Math.sqrt(this.particles[i].a_x * this.particles[i].a_x + this.particles[i].a_y * this.particles[i].a_y);
      //canvasUtil.println(`new acceleration norm = ${acc_norm}`);
      if (acc_norm > ACC_MAX) {
        this.particles[i].a_x *= ACC_MAX / acc_norm;
        this.particles[i].a_y *= ACC_MAX / acc_norm;
      }
      //canvasUtil.println(`new acceleration = (${this.particles[i].a_x}, ${this.particles[i].a_y})`);

      // update velocity
      // if speed is too high, rescale the veclocity vector to have appropriate length
      this.particles[i].v_x += this.particles[i].a_x;
      this.particles[i].v_y += this.particles[i].a_y;
      let speed = Math.sqrt(this.particles[i].v_x * this.particles[i].v_x + this.particles[i].v_y * this.particles[i].v_y);
      if (speed > SPEED_MAX) {
        this.particles[i].v_x *= SPEED_MAX / speed;
        this.particles[i].v_y *= SPEED_MAX / speed;
      }
      //speed = Math.sqrt(this.particles[i].v_x * this.particles[i].v_x + this.particles[i].v_y * this.particles[i].v_y);
      //canvasUtil.println(`new speed = ${speed})`);

      //canvasUtil.println(`new velocity = (${this.particles[i].v_x}, ${this.particles[i].v_y})`);

  		// if keeping the particles inside the canvas...
  		if (document.getElementById("confine").value == 0) {
  			if (this.particles[i].xs[0] + this.particles[i].v_x > WIDTH || this.particles[i].xs[0] + this.particles[i].v_x < 0) {
  				this.particles[i].v_x *= -1.0;
        }
  			if (this.particles[i].ys[0] + this.particles[i].v_y > HEIGHT || this.particles[i].ys[0] + this.particles[i].v_y < 0) {
  				this.particles[i].v_y *= -1.0;;
        }
  		}

  		// get new position
      let pos_x = this.particles[i].xs[0] + this.particles[i].v_x;
      let pos_y = this.particles[i].ys[0] + this.particles[i].v_y;

      //canvasUtil.println(`new position = (${pos_x}, ${pos_y})`);

  		// keep track of previous positions
      this.particles[i].xs = [pos_x].concat(this.particles[i].xs.slice(0, TAIL - 1));
      this.particles[i].ys = [pos_y].concat(this.particles[i].ys.slice(0, TAIL - 1));
  	}
  }
}

function draw() {
  if (paused) {
    return 0;
  }

  canvasUtil.clearCanvas("white");
  ensemble.updateState();
  ensemble.drawAttractors();
  ensemble.drawParticles();

  // ensemble.attractors.slice(0, NUM_ATTRACTORS).forEach(a => a.draw());
  //ensemble.particles.slice(0, NUM_PARTICLES).forEach(p => p.draw());
  //canvasUtil.println("drew a frame");
  //ensemble.particles.slice(0, 1).forEach(p => canvasUtil.println(p.toString()));
}


function init(){
	canvas = document.getElementById("canvas");
	canvas.width = WIDTH;
	canvas.height = HEIGHT;
	if (canvas.getContext){
		ctx = canvas.getContext('2d');
    canvasUtil = new CanvasUtil(ctx, WIDTH, HEIGHT, document.outform.output);
		// set up the particles	and attractors
    ensemble = Ensemble.makeRandom(NUM_PARTICLES_MAX, NUM_ATTRACTORS_MAX);
    //ensemble.particles.forEach(p => canvasUtil.println(p.toString()));
    //ensemble.attractors.forEach(a => canvasUtil.println(a.toString()));

    //canvasUtil.println(ensemble.toString());

    //this.ensemble.particles.slice(0, 1).forEach(p => canvasUtil.println(p.toString()));
    //this.ensemble.attractors.forEach(a => canvasUtil.println(a.toString()));
		//makeParticles();
		//makeAttractors();

		// call the drawing function
		//return setInterval(ensemble.draw, 10);
    return setInterval(draw, 5);
	}
	else {
    alert('You need a better web browser to see this.');
  }
}

partSl.onchange = function () {
  document.getElementById("part-view").value = partSl.getValue();
	NUM_PARTICLES = parseInt(partSl.getValue());
    canvasUtil.println(`new number of particles = ${NUM_PARTICLES}`);
};

attSl.onchange = function () {
  document.getElementById("att-view").value = attSl.getValue();
	NUM_ATTRACTORS = parseInt(attSl.getValue());
  canvasUtil.println(`new number of attractors = ${NUM_ATTRACTORS}`);
};

gSl.onchange = function () {
  document.getElementById("g-view").value = gSl.getValue();
	G_POW = parseInt(gSl.getValue());
  canvasUtil.println(`new Gravity exponent = ${G_POW}`);
};

window.onresize = function () {
	partSl.recalculate();
	attSl.recalculate();
	gSl.recalculate();
	init();
};
</script>

</div>

<div class="middle">
    <canvas id="canvas" width="750" height="750">
        <p>Your browser is currently unsupported.</p>
        <p>Supported browsers: <a href="http://www.opera.com">Opera</a>, <a
          href="http://www.mozilla.com">Firefox</a>, <a
          href="http://www.apple.com/safari">Safari</a>, and <a
          href="http://www.konqueror.org">Konqueror</a>.</p>
    </canvas>
</div>

<div class="middle">
<table align="center">
	<tr>
		<td><form name="outform">
		    <textarea rows="25" cols="80" name="output"></textarea>
		    </form>
		</td>
	</tr>
</table>
</div>

<div class="bottom">
<p>last modified: 12/31/2019</p>
</div>

</div>

</body>
</html>
