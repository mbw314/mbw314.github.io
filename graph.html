<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />	
	<title>Michael Bradford Williams</title>
	<link rel="stylesheet" type="text/css" href="./css/styles.css" /> 
	<link rel="shortcut icon" href="favicon.ico" />
	<script language="JavaScript" type="text/javascript" src="./js/jscript.js"></script>
	<script language="JavaScript" type="text/javascript" src="./js/graph.js"></script>
	  <script type="application/x-javascript">
<!--  

var x = 150;
var y = 150;
var x_mouse, y_mouse, dragHoldX, dragHoldY, mouseX, mouseY;
var dx = 2;
var dy = 4;
var canvas,ctx;
var width = 750;//window.innerWidth;
var height = 500;//window.innerHeight;
//var WIDTH, HEIGHT;
var time0 = 0;
var time1 = 0;
var g = new Graph([],[]);
var dragging = false;
var dragIndex = 0;
var t_default = 3;
var c_default = "#000000";
var type = "rand";
var N = 7;
var M = 2;

var canvasMinX;
var canvasMinY;

function init(){

	var date0 = new Date();
	time0 = date0.getTime();
	document.outform.output.value = ""; 

	// get the canvas element using the DOM
	canvas = document.getElementById("canvas");
	canvas.width = width;
	canvas.height = height;
	//WIDTH = canvas.width;
	//HEIGHT = canvas.height;
	
	canvasMinX = findPos(canvas)[0];
	canvasMinY = findPos(canvas)[1];	
	
	// Make sure we don't execute when canvas isn't supported
	if (canvas.getContext){
		// use getContext to use the canvas for drawing
		ctx = canvas.getContext('2d');	
		
		// Attach the event handlers
		canvas.addEventListener('mousemove', ev_mousemove, false);	
		canvas.addEventListener("mousedown", mouseDownListener, false);
		window.addEventListener("mouseup", mouseUpListener, false);
		window.addEventListener("dblclick", mouseDblclickListener, false);
		
		// which graph to make?
		//document.outform.output.value += "init called with " 
		//			+ type + " " + N + " " + M + '\n';
		
		if( type == "rand" ) {
			g = randomGraph(N,width,height);
			document.outform.output.value += "drew random graph with " + N + " vertices" + '\n';
		}
		else if( type == "comp" ) {
			g = completeGraph(N,width,height);
			document.outform.output.value += "drew complete graph with " + N + " vertices" + '\n';
		}
		else if( type == "bipt" ) {
			g = completeBipartiteGraph(N,M,width,height);
			document.outform.output.value += "drew complete bipartite graph with " + N + " + " + M + " vertices" + '\n';
		}
		else if( type == "grid") {
			g = gridGraph(N,M,width,height);
			document.outform.output.value += "drew grid graph with " + N + " x " + M + " vertices" + '\n';
		}
						
		//g = completeBipartiteGraph(3,3);
		//g = completeGraph(4);
		//g = randomGraph(8);
		//g = grid(7,4);
		
		/*
		g = new Graph([],[]);
		
		v1 = new Vertex(1,50,50);
		v2 = new Vertex(2,300,300);
		v3 = new Vertex(3,300,50);
		v4 = new Vertex(4,50,300);
		
		g.addVertex(v1);
		g.addVertex(v2);
		g.addVertex(v3);
		g.addVertex(v4);
		
		g.addEdge( new Edge(v1,v2) );
		g.addEdge( new Edge(v2,v3) );
		g.addEdge( new Edge(v3,v4) );
		*/
		
		// test intersection
		/*
		document.outform.output.value = intersects(
			g.edges[0].v0.xCoord,
			g.edges[0].v0.yCoord,
			g.edges[0].v1.xCoord,
			g.edges[0].v1.yCoord,
			g.edges[1].v0.xCoord,
			g.edges[1].v0.yCoord,
			g.edges[1].v1.xCoord,
			g.edges[1].v1.yCoord);
		*/
		// call the drawing function
		return setInterval(draw, 10);	
		//draw();
	} 
	else { alert('You need a better web browser to see this.'); }
}	

function circle(x,y,r) {
	ctx.beginPath();
	ctx.arc(x, y, r, 0, Math.PI*2, true);
	ctx.closePath();
	ctx.fill();
}

function rect(x,y,w,h) {
	ctx.beginPath();
	ctx.rect(x,y,w,h);
	ctx.closePath();
	ctx.fill();
}

function clear() {
	ctx.fillStyle = "#FFFFFF";
	rect(0, 0, width, height);
}

function draw() {

	clear();

	for( var i=0; i<g.vertices.length; i++ ) 
		if( g.vertices[i].hitTestVertex(x_mouse,y_mouse) ) 
			g.vertices[i].halo = true;

	for( var j=0; j<g.edges.length; j++ ) 
		if( g.edges[j].hitTestEdge(x_mouse,y_mouse) ) 
			g.edges[j].halo = true;
	
	g.drawGraph(ctx);
	g.resetHalos();
}

function ev_mousemove (ev) {
	// Get the mouse position relative to the canvas element.
	if (ev.layerX || ev.layerX == 0) { // Firefox
		x_mouse = ev.layerX - canvasMinX;
		y_mouse = ev.layerY - canvasMinY;
	} else if (ev.offsetX || ev.offsetX == 0) { // Opera
		x_mouse = ev.offsetX - canvasMinX;
		y_mouse = ev.offsetY - canvasMinY;
	}
}

// find the position of the upper-left corner of an object (e.g., the canvase)
function findPos(obj) {
	var curLeft = 0;
	var curTop = 0;
	
	if(obj.offsetParent) {
		
		do {
			curLeft += obj.offsetLeft;
			curTop += obj.offsetTop;
		} while (obj = obj.offsetParent);
	}
	
	return [curLeft,curTop];
}

function mouseMoveListener(evt) {

	var posX;
	var posY;
	var shapeRad = g.vertices[dragIndex].radius;
	var minX = shapeRad;
	var maxX = canvas.width - shapeRad;
	var minY = shapeRad;
	var maxY = canvas.height - shapeRad;
	//getting mouse position correctly 
	var bRect = canvas.getBoundingClientRect();
	mouseX = (evt.clientX - bRect.left)*(canvas.width/bRect.width);
	mouseY = (evt.clientY - bRect.top)*(canvas.height/bRect.height);
	
	//clamp x and y positions to prevent object from dragging outside of canvas
	posX = mouseX - dragHoldX;
	posX = (posX < minX) ? minX : ((posX > maxX) ? maxX : posX);
	posY = mouseY - dragHoldY;
	posY = (posY < minY) ? minY : ((posY > maxY) ? maxY : posY);
	
	g.vertices[dragIndex].xCoord = posX;
	g.vertices[dragIndex].yCoord = posY;
	
	//draw();
		
}

function mouseDownListener(evt) {

	//document.outform.output.value += "mousedown" + '\n';
	
	var i;
	//We are going to pay attention to the layering order of the objects so 
	//that if a mouse down occurs over more than object, only the topmost one 
	//will be dragged.
	var highestIndex = -1;
	
	//getting mouse position correctly, being mindful of resizing that may 
	//have occured in the browser:
	var bRect = canvas.getBoundingClientRect();
	mouseX = (evt.clientX - bRect.left)*(canvas.width/bRect.width);
	mouseY = (evt.clientY - bRect.top)*(canvas.height/bRect.height);
			
	//find which vertex was clicked
	for (i=0; i < g.vertices.length; i++) {
		if( g.vertices[i].hitTestVertex(x_mouse,y_mouse) ) {
			dragging = true;
			if (i > highestIndex) {
				//We will pay attention to the point on the object 
				//where the mouse is "holding" the object:
				dragHoldX = mouseX - g.vertices[i].xCoord;
				dragHoldY = mouseY - g.vertices[i].yCoord;
				highestIndex = i;
				dragIndex = i;
			}
		}
	}
		
	if (dragging) {
		window.addEventListener("mousemove", mouseMoveListener, false);
	}
	canvas.removeEventListener("mousedown", mouseDownListener, false);
	window.addEventListener("mouseup", mouseUpListener, false);
		
	//code below prevents the mouse down from having an effect on the main
	//browser window:
	if (evt.preventDefault) {
		evt.preventDefault();
	} //standard
	else if (evt.returnValue) {
		evt.returnValue = false;
	} //older IE
	return false;

}

function mouseUpListener(evt) {

	//document.outform.output.value += "mouseup" + '\n';
	
	g.resetHalos();

	canvas.addEventListener("mousedown", mouseDownListener, false);
	window.removeEventListener("mouseup", mouseUpListener, false);
	if (dragging) {
		dragging = false;
		window.removeEventListener("mousemove", mouseMoveListener, false);
	}

}

function mouseDblclickListener(evt) {
	
	for( var i=0; i < g.vertices.length; i++) {
		if( g.vertices[i].hitTestVertex(x_mouse,y_mouse) ) {
			//document.outform.output.value += g.vertices[i].printVertexData() + '\n';
			
			// deselect a selected vertex
			if( g.vertices[i].selected && g.selectedVertexIndex != -1 ) {
				g.vertices[i].selected = false;
				g.selectedVertexIndex = -1;
				//document.outform.output.value += "deselected vertex " + g.vertices[i].name + '\n';
			}
			// select an unselected vertex
			else if( !g.vertices[i].selected && g.selectedVertexIndex == -1 ) {
				g.vertices[i].selected = true;
				g.selectedVertexIndex = i;
				//document.outform.output.value += "selected vertex " + g.vertices[i].name + '\n';
			}				
		}
	}
	
	for( var j=0; j < g.edges.length; j++) {
		if( g.edges[j].hitTestEdge(x_mouse,y_mouse) ) {
			// deselect a selected edge
			if( g.edges[j].selected && g.selectedEdgeIndex != -1 ) {
				g.edges[j].selected = false;
				g.selectedEdgeIndex = -1;
				//document.outform.output.value += "deselected edge (" + g.edges[j].v0.name + "," + g.edges[j].v1.name + ")" + '\n';
			}
			// select an unselected edge
			else if( !g.edges[j].selected && g.selectedEdgeIndex == -1 ) {
				g.edges[j].selected = true;
				g.selectedEdgeIndex = j;
				//document.outform.output.value += "selected edge (" + g.edges[j].v0.name + "," + g.edges[j].v1.name + ")" + '\n';
			}				
		}
	}
	
}

function reduce() {
	if( g.selectedVertexIndex != -1 ) {
		g.seriesReduce();
		g.selectedVertexIndex = -1;
	}
}

function deleteAVertex() {
	if( g.selectedVertexIndex != -1 ) {
		g.deleteVertex(g.vertices[g.selectedVertexIndex]);
		g.selectedVertexIndex = -1;
	}
}

function deleteAnEdge() {
	if( g.selectedEdgeIndex != -1 ) {
		g.deleteEdgeByIndex(g.selectedEdgeIndex);
		g.selectedEdgeIndex = -1;
	}
}

function isItK5() {
	if( g.isIsomorphicToKn(5) ) 
		document.outform.output.value += "  isomorphic to K5: yes" + '\n';
	else
		document.outform.output.value += "  isomorphic to K5: no" + '\n';
}

function isItK33() {
	if( g.isIsomorphicToK33() ) 
		document.outform.output.value += "  isomorphic to K33: yes" + '\n';
	else
		document.outform.output.value += "  isomorphic to K33: no" + '\n';
}

function isPlanar() {
	if( g.isPlanarDrawing() ) 
		document.outform.output.value += "  planar drawing: yes" + '\n';
	else
		document.outform.output.value += "  planar drawing: no" + '\n';
}

function updateGraph(newType,newN,newM) {

	//document.outform.output.value += "called updateGraph with " 
	//				+ newType + " " + newN + " " + newM + '\n';
	
	if( newType == "rand" )
		type = "rand";
	else if( newType == "comp" )
		type = "comp";
	else if( newType == "bipt" )
		type = "bipt";
	else if( newType == "grid" )
		type = "grid";
		
	N = parseInt(newN);
	M = parseInt(newM);
	
	//document.outform.output.value += "updated parameters: " 
	//				+ type + " " + N + " " + M + '\n';
	
	init();	
}


-->
	</script>	
</head>
  
<body onload="init();">

<div class="container">

<div class="topsmall">

<div class="topleftsmall">
   <a href="./index.html">
	<script type="text/javascript">
      		showImage("300x50");
   	</script>
   </a>
</div>

<h1><a href="./index.html">Michael Bradford Williams</a></h1>

</div>

<div class="middle">

<h2>Graphs and Planarity</h2>

<p>A <a href="http://en.wikipedia.org/wiki/Graph_%28mathematics%29">graph</a> is <a href="http://en.wikipedia.org/wiki/Planar_graph">planar</a> if it can be drawn so that there are no edge crossings (except at vertices).  As an arbitrary graph can be drawn in many different ways, it might seem hopeless to characterize when it is planar, but there is a remarkable theorem of <a href="http://en.wikipedia.org/wiki/Kazimierz_Kuratowski">Kuratowski</a>.  It says that a graph is planar if and only if it does not contain a subgraph that can be reduced via series reductions to K<sub>5</sub> or K<sub>3,3</sub>.</p>

<p>Here, a "series reduction" replaces a vertex of degree 2 with a single edge:</p>
<table  align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr align="center">
        <td><img src="./images/series_reduction.png" alt="a series reduction" /></td>
</tr>
</table>
<p>and K<sub>5</sub> and K<sub>3,3</sub> are the following graphs:</p>
<table  align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr align="center">
        <td><img src="./images/k5.png" alt="k5" /></td>
        <td><img src="./images/k33.png" alt="k33" /></td>
</tr>
</table>

<p>The theorem essentially says that if you can arrive at either to K<sub>5</sub> or K<sub>3,3</sub> by deleting vertices or edges, and by performing series reductions, then the graph is not planar, and vice versa.
</p>

<p>The program below allows you to test whether or not is planar.  You can draw a variety of graphs, delete vertices and edges, and perform series reductions to obtain subgraphs.  You can drag vertices to 
change the drawing of the graph, and double-click on a vertex or edge to 
select it.  You can test whether the current subgraph is isomorphic to K<sub>5</sub> or K<sub>3,3</sub>, or drawn in a planar fashion.</p>

<p>You'll need a modern browser to view the app. It has been tested in <a
href="http://www.mozilla.com/firefox/">Firefox</a> (Windows/Linux).</p>

</div>

<div class="middle">

<form name="parameters" action="#">
<table border="0" align="center">
<tr>
	<td colspan="1" align="right">
			Graph:
	</td>
	<td colspan="1" align="left">
		<select name="graphOption">
			<option value="rand" selected="selected">random on n vertices</option>
			<option value="comp">complete on n vertices</option>
			<option value="bipt">complete bipartite on n, m vertices</option>
			<option value="grid">grid with n rows, m columns</option>
		</select> n:
		<select name="nVertices">	
	    		<option value="1">1</option>
	    		<option value="2">2</option>
	    		<option value="3">3</option>
			<option value="4">4</option>
			<option value="5">5</option>
			<option value="6">6</option>
			<option value="7" selected="selected">7</option>
			<option value="8">8</option>
			<option value="9">9</option>
			<option value="10">10</option>
			</select> m:
		<select name="mVertices">	
			<option value="1">1</option>
	    		<option value="2" selected="selected">2</option>
	    		<option value="3">3</option>
			<option value="4">4</option>
			<option value="5">5</option>
			<option value="6">6</option>
			<option value="7">7</option>
			<option value="8">8</option>
			<option value="9">9</option>
			<option value="10">10</option>
		</select>
		<input type="button" name="draw" value="Draw New Graph" 
		       onclick="updateGraph(parameters.graphOption.value, 
					parameters.nVertices.value, 
					parameters.mVertices.value);" />
	</td>
</tr>
<tr>
	<td align="right">
		Reductions:
	</td>
	<td align="left">
		<input type="button" name="seriesReduce" value="Series Reduction" onclick="reduce();" />
		<input type="button" name="deleteVertex" value="Delete Vertex" onclick="deleteAVertex();" />
		<input type="button" name="deleteEdge" value="Delete Edge" onclick="deleteAnEdge();" />
	</td>
</tr>
<tr>
	<td align="right">
		Tests:
	</td>
	<td align="left">
		<input type="button" name="k5" value="Isomorphic to K_5?" onclick="isItK5();" />
		<input type="button" name="k33" value="Isomorphic to K_3,3?" onclick="isItK33();" />
		<input type="button" name="planar" value="Planar Drawing?" onclick="isPlanar();" />
	</td>
</tr>
</table>
</form>
</div>
  
<div class="middle">  
<center>
    <canvas id="canvas" width="750" height="500">
        <p>Your browser is currently unsupported.</p>
        <p>Supported browsers: <a href="http://www.opera.com">Opera</a>, <a 
          href="http://www.mozilla.com">Firefox</a>, <a 
          href="http://www.apple.com/safari">Safari</a>, and <a 
          href="http://www.konqueror.org">Konqueror</a>.</p>
    </canvas>
</center>
</div>


<div class="middle">

<form name="outform" action="#">   
	<textarea rows="5" cols="75" name="output"></textarea>    
</form>
		
</div>

<div class="bottom">
<p>last modified: 8/20/2014</p>

</div>

</div>

</body>
</html>
