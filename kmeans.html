<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/2000/REC-xhtml1-20000126/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />	
	<title>Michael Bradford Williams</title>
	<link rel="stylesheet" type="text/css" href="./css/styles.css" /> 
	<link rel="shortcut icon" href="favicon.ico" />
	<script language="JavaScript" type="text/javascript" src="./js/jscript.js"></script>
	  <script type="application/x-javascript">
<!--  

var canvas,ctx;
var width = window.outerWidth;
var height = window.outerHeight;
var WIDTH, HEIGHT;
var canvasMinX;
var canvasMinY;
var posX, posY, mouseX, mouseY;

var m = 50; 
var points = [];
var clusterIndex = [];
var pointColor = [];
var pointRadius = 10;
var K = 5;
var centroids = [];
var centroidColor = [];
var centroidRadius = 15;
var tempDist = [];
var oldCentroids = [];
var oldCentroidColor = 'gray';
var centroidLines = [];


function indexOfSmallest(a) {
	var lowest = 0;
	for(var i=1; i < a.length; i++) {
  		if (a[i] < a[lowest]) lowest = i;
 	}
 	return lowest;
}

function countInArray(a,i){
	var result = 0;
	
	for(var o in a) {
		if(a[o] == i) {
			result++;
		}
	}
	return result;
}

function getAllIndexes(a, v) {
    var indexes = [], i;
    for(i = 0; i < a.length; i++)
        if (a[i] === v)
            indexes.push(i);
    return indexes;
}


function kMeansIter() {

	// step 1: cluster assignment
	for(var i=0; i<m; i++) {
		// for each data point, compute distances to all centroids
		for(var k=0; k<K; k++) {
			tempDist[k] = (points[i][0]-centroids[k][0])*(points[i][0]-centroids[k][0])
					+ (points[i][1]-centroids[k][1])*(points[i][1]-centroids[k][1]);
		}
		// find index corresponding to smallest distance
		clusterIndex[i] = indexOfSmallest(tempDist);
		//set the color of the data point to the color of the new centroid
		pointColor[i] = centroidColor[clusterIndex[i]];
	}

	// step 2: centroid movement
	var tempX = 0;
	var tempY = 0;
	var cluster = [];

	for(var k=0; k<K; k++) {
	
		var L = oldCentroids.push([centroids[k][0],centroids[k][1]]);
	
		cluster = getAllIndexes(clusterIndex,k);
		
		if( cluster.length != 0 ) {
			// if the cluster is non-empty, proceed
			tempX = 0;
			tempY = 0;
		
			// calculate mean of all points in given cluster
			for(var j=0; j < cluster.length; j++) {
				tempX += points[cluster[j]][0];
				tempY += points[cluster[j]][1];
			}
		
			// move the centroid to this new mean
			centroids[k][0] = tempX/cluster.length;
			centroids[k][1] = tempY/cluster.length;
		}
		else {
			// if the cluster is empty, remove the corresponding centroid
			//var removed = centroids.splice(k,1);
			//k = k-1;
			
			// reassign the centroid randomly
			centroids[k] = [Math.random()*WIDTH, Math.random()*HEIGHT];
		}
		
		L = centroidLines.push([oldCentroids[oldCentroids.length-1][0],
						    oldCentroids[oldCentroids.length-1][1],
						    centroids[k][0],
						    centroids[k][1]]);
	}
}

function initPoints(num) {

	m = num;
	for(var i=0; i<m; i++) {
		points[i] = [Math.random()*WIDTH, Math.random()*HEIGHT];
		clusterIndex[i] = 0;
		pointColor[i] = [0, 0, 0];
	}
}

function initCentroids(num) {

	K = num;
	for(var k=0; k<K; k++) {
		centroids[k] = [Math.random()*WIDTH, Math.random()*HEIGHT];
				 //= [points[k][0], points[k][1]]; 
		centroidColor[k] = [Math.round(k*255/K), 
						Math.round((K-k)*255/K), 
						Math.round(Math.random()*255)];
	}
}

		
function drawPoints() {

	for(var i=0; i<m; i++) {
		drawDot(points[i][0],
			   points[i][1],
			   pointRadius,
			   'rgb(' + pointColor[i][0] + ',' 
			   + pointColor[i][1] + ',' 
			   + pointColor[i][2] + ')');
	}
}

function drawCentroids() {

	for(var k=0; k<K; k++) {
		drawCircle(centroids[k][0],
			      centroids[k][1],
			      centroidRadius,
			      'rgb(' + centroidColor[k][0] + ',' 
			      + centroidColor[k][1] + ',' 
			      + centroidColor[k][2] + ')');
	}
	
	for(var j=0; j<oldCentroids.length; j++) {
		drawCircle(oldCentroids[j][0],
			      oldCentroids[j][1],
			      centroidRadius/2,
			      oldCentroidColor);
	}
	
}

function drawCentroidPaths() {

	for(var j=0; j<centroidLines.length; j++) {
		drawLine(centroidLines[j][0],
			    centroidLines[j][1],
			    centroidLines[j][2],
			    centroidLines[j][3],
			    oldCentroidColor);
	}
}

function drawConnectors() {

	var cluster = [];

	for(var k=0; k<K; k++) {
	
		cluster = getAllIndexes(clusterIndex,k);
		
		for(var j=0; j<cluster.length; j++) {
		
			drawLine(centroids[k][0],
					centroids[k][1],
					points[cluster[j]][0],
					points[cluster[j]][1],
					'black');
		}
	
	}
}

function init(){

	// get the canvas element using the DOM
	canvas = document.getElementById("canvas");
	canvas.width = 750;//width - 25;
	canvas.height = 750;//height - 125;	
	WIDTH = canvas.width;
	HEIGHT = canvas.height;
	
	canvasMinX = findPos(canvas)[0];
	canvasMinY = findPos(canvas)[1];	
	
	// Make sure we don't execute when canvas isn't supported
	if (canvas.getContext){
		// use getContext to use the canvas for drawing
		ctx = canvas.getContext('2d');	

		refreshData();

	}
	else { alert('You need a better web browser to see this.'); }
}	


function rect(x,y,w,h) {
	ctx.beginPath();
	ctx.rect(x,y,w,h);
	ctx.closePath();
	ctx.fill();
}

function clear() {
	ctx.fillStyle = 'white';
	rect(0, 0, WIDTH, HEIGHT);
}

function drawLine(x0,y0,x1,y1,c) {
	ctx.beginPath();
	ctx.strokeStyle = c;
	ctx.moveTo(x0,y0);
	ctx.lineTo(x1,y1);
	ctx.closePath();
	ctx.stroke();	
}

function drawDot(x,y,r,c) {
	ctx.beginPath();		
	ctx.fillStyle = c;
	ctx.arc(x,y,r,0,2*Math.PI,true);
	ctx.closePath();
	ctx.fill();
}

function drawCircle(x,y,r,c) {
	ctx.beginPath();
	ctx.strokeStyle = c;		
	ctx.arc(x,y,r,0,2*Math.PI,true);
	ctx.closePath();
	ctx.stroke();
}


// find the position of the upper-left corner of an object (e.g., the canvas)
function findPos(obj) {
	var curLeft = 0;
	var curTop = 0;
	
	if(obj.offsetParent) {		
		do {
			curLeft += obj.offsetLeft;
			curTop += obj.offsetTop;
		} while (obj = obj.offsetParent);
	}
	
	return [curLeft,curTop];
}

function refreshData() {
	
	clear();
	
	oldCentroids = [];
	centroidLines = [];

	initPoints(m);
	drawPoints();
		
	initCentroids(K);
	drawCentroids();
}

function iterate() {
	
	clear();
	kMeansIter();
	drawConnectors();
	drawCentroids();
	drawCentroidPaths();
	drawPoints();
}


-->
	</script>	
</head>
  
<body onload="init();">

<div class="container">

<a href="./index.html">
<div class="topsmall">

<div class="topleftsmall">
  <a href="./index.html">
   <script type="text/javascript">
      showImage("300x50");
   </script>
  </a>
</div>

<h1>Michael Bradford Williams</h1>

</div>
</a>

<div class="middle">

<h2>K-means Clustering</h2>

<p>Below is a visual representation of the <a href="http://en.wikipedia.org/wiki/K-means_clustering">K-means clustering</a> algorithm. This is a <a href="http://en.wikipedia.org/wiki/Machine_leanring">machine learning</a> algorithm that attempts to group a set of (unlabeled) data points into clusters according to proximity.</p>

<p>The algorithm first initializes a set of K "centroids", which are to be the geometric centers of the data clusters. Then, there is a repeating loop that has two main steps:</p>
<ol>
<li>Cluster assignments: decide to which cluster each data point belongs. This is done by finding the centroid that is closest to the data point in question.</li>
<li>Centroid updating: try to improve the position of the centroids. This is done by moving a given centroid to the average (mean) position of all points in that centroid's cluster.</li>
</ol>

<p>Instructions for this demonstration: the data used here consists of 50 randomly selected points in the plane, and the algorithm tries to group those points into 5 clusters. The centroids initialized randomly. Press "Iterate" to step through one iteration of the algorithm. You can see how the centroids move, and how data may move from one cluster to another (by changing color). Press "Reset" to reset data and clusters.</p>

<p>You'll need a modern browser to view the app. It has been tested in <a
href="http://www.mozilla.com/firefox/">Firefox</a> (Windows/Linux) and <a
href="http://www.google.com/chrome">Chrome</a> (Windows).</p>

</div>

<div class="middle">
<table border="0" align="center">
	<tr>
		<td align="left">
			<input type="button" name="iterate" value="Iterate" onClick="iterate();">
			<input type="button" name="reset" value="Reset" onClick="refreshData();">
		</td>
	</tr>
</table>
</div>

<div class="middle">  
<center>
    <canvas id="canvas" width="750" height="750">
        <p>Your browser is currently unsupported.</p>
        <p>Supported browsers: <a href="http://www.opera.com">Opera</a>, <a 
          href="http://www.mozilla.com">Firefox</a>, <a 
          href="http://www.apple.com/safari">Safari</a>, and <a 
          href="http://www.konqueror.org">Konqueror</a>.</p>
    </canvas>
</center>
</div>

<div class="bottom">
<p>last modified: 11/25/2014</p>

</div>

</div>

</body>
</html>
